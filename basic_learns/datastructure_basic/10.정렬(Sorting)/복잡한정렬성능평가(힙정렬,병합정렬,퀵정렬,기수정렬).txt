시간복잡도에 대한 빅-오

			비교연산			이동연산
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
힙 정렬		O(nlog2n)
병합 정렬		O(nlog2n)		O(nlog2n)
퀵 정렬		O(nlog2n)
기수 정렬		O(ln)	//l : 데이터의 길이 , n : 정렬 데이터 수


------------------------------------------------------------------------------------------

1.힙 정렬(Heap Sort) 
-힙의 데이터 저장 시간 복잡도 O(log2n)
-힙의 데이터 삭제 시간 복잡도 O(log2n)
=>삽입과 삭제에 대한 시간 복잡도 2log2n => O(log2n)
=>정렬의 대상 수가 n이면 총n개의 데이터를 삽입 및 삭제해야 하므로
=>O(nlong2n)

------------------------------------------------------------------------------------------

2.병합 정렬(Merge Sort)
=>병합정렬에 핵심은 병합의 과정에 있음.

	while (fIdx <= mid&&rIdx <= right) {
		if (arr[fIdx] < arr[rIdx]) {	//핵심이 되는 비교연산
			sortArr[sIdx] = arr[fIdx++];
		}
		else {
			sortArr[sIdx] = arr[rIdx++];
		}
		sIdx++;
	}

=>데이터가 n개 있을때, 병합의 과정은 총 K(단계)=log2n	

	
1)비교연산
 eg)15	46을 병합할때
	1)1과4 비교 후 1이동
	2)5와4 비교 후 4이동
	3)5와6 비교 후 5이동
	4)6을 이동하기 위한 비교 <<추가적인 비교 연산(빅오를 구하기 위한?)

=>데이터가 n개 일때, 병합의 각 단계마다 최대 n번의 비교연산이 진행.	
=>(8개의 데이터가 있을때, 병합과정 총 3단계 진행 // 16개이면 4단계 진행) =>k(단계)=log2n
=>O(nlog2n)


2)이동연산
-임시 배열에 데이터를 병합하는 과정에서 한 번
-임시 배열에 저장된 데이터 전부를 원위치로 옮기는 과정에서 한번

=>
각 단계마다 n개의 데이터 이동 & 원본으로 이동 => 2n번 이동
=>n개의 데이터가 있을때 k단계=log2n
=>2nlog2n
=>O(nlog2n)

==>이동연산이 부담스럽게 느껴질 수 있음. 그런데 빅-오는 nlog2n이므로 생각보다 의외로 부담되는 것은 아님!
	
------------------------------------------------------------------------------------------

3.퀵정렬(QuickSort)

=>low는 오른쪽, high는 왼쪽으로 이동 =>  이 과정에서 피벗과의 비교를 매번 수반하므로 하나의 피벗이 제자리를 찾아가는 과정에서 발생하는 비교 연산의 횟수는 n
=>그다음 분할을 할 경우 n-1회의 비교 연산 => 빅오 관점에서 -1은 무시.
=>나눠지는 단계 K * n => 시간복잡도

e.g)31개의 데이터를 대상으로 퀵정렬 할 경우 피벗이 항상 중간 값으로 결정되는 이상적인 경우
1차나뉨	: 31개 데이터 -> 15개씩 2조각이됨
2차나뉨	: 이어서 각각 7개씩 4조각
3차나뉨	: 이어서 각각 3개씩 8조각
4차나뉨	: 이어서 각각 1개씩 둘로 나뉘어 총 16조각

=>k=log2n
=>O(nlog2n)

cf)퀵정렬에서 최선의 경우를 하는 이유 
:'중간에 가까운 피벗을 선택하는 방법'을 적용함으로써 늘 최선의 경우를 보이는 것은 아니지만, 최선의 경우에 가까운 성능을 평균적으로 보이기 때문.

=>최악의 경우(이미 정렬된 상태 & 피벗이 가장 적은 값으로 결정)
=>k=n =>O(n^2)
 
==>아무도 이 결과를 기준으로 퀵 정렬을 평가하지 않음. 실제로 퀵 정렬은 O(nlog2n)의 복잡도를 갖는 다른 알고리즘과 비교 했을때 가장 좋은 성능
	(데이터 이동 횟수가 상대적으로 적고, 병합 정렬과 같이 별도의 메모리 공간을 요구하지 않음)
	



------------------------------------------------------------------------------------------

4.기수정렬(Radix Sort)
;기수 정렬의 핵심 연산은 데이터의 삽입과 추출 (비교 연산이 아님)


	//가장 긴 데이터의 길이만큼 반복
	for (pos = 0; pos < maxLen; pos++) {
		...
		//정렬대상의 수만큼 버킷에 데이터 삽입
		for (di = 0;di < num; di++) {
			//버킷으로 데이터 삽입
		}
		
		//정렬대상의 수만큼 버킷으로부터 데이터 추출		
		for (bi=0,di = 0; bi < BUCKET_NUM; bi++) {
			//버킷으로부터의 데이터 추출 진행
		}
		...
	}

=>버킷을 대상으로 하는 데이터의 삽입과 추출을 한 쌍의 연산으로 묶으면, 이 한쌍의 연산이 수행하는 횟수
 ==maxLen x num
=>정렬대상 n // 길이가 l 일때 시간 복잡도에 대한 기수 정렬의 빅-오 == O(ln)
=>빅-오 관점에서 O(n)으로 봐도 무방.
=>다른 정렬들의 한계인 O(nlog2n)을 넘음. BUT 제한적

------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------
	
	
	
















	