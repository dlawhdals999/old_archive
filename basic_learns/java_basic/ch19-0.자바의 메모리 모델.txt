-------------------ch19.자바의 메모리 모델과 Object 클래스-----------------------

//19-1. 자바 가상머신의 메모리 모델 (자바 가상머신의 메모리 관리방식)

(Intro)
JVM <--OS <-- C.A(Computer Achitecture) 와 관련 있음
(어느정도는 알아야되지만, 100%다 알아야 프로그래밍 할 수 있는 것은 아님
 한번에 알려는게 아니라 공부하다가 더 많이 아는게 중요)
---------------------------------------------------
//JVM 은 운영체제 위에서 동작한다.

메인 메모리(Main memory) : 프로그램의 실행에 필요한 메모리 // 물리적으로 램(RAM)
=>이를 효율적으로 사용하기 위해 운영체제가 응용프로그램에게 메모리를 할당.

-운영체제가 JVM을 포함해서 모든 응용 프로그램에게 동일한 크기의 메모리 공간을 
 할당 할 수 있는 이유는 가상 메모리 기술에서 찾을 수 있다.

-JVM은 운영체제로부터 할당받은 메모리 공간을 기반으로 자바 프로그램을 실행해야 한다.

-JVM은 운영체제로부터 할당받은 메모리 공간을 이용해서 자기 자신도 
 실행(JVM도 프로그램 중 하나)을 하고, 자바 프로그램도 실행을 한다.

*가상메모리 : 

   			Operating System

(동일한 메모리 할당) (동일한 메모리 할당) (동일한 메모리 할당)
  응용프로그램1(4G)    응용프로그램2(4G)          JVM(4G)

-C vs JAVA
C,C++은 운영체제 위에서 어떻게 하느냐
JAVA 는 운영체제 위에서 JVM 이 어떻게 하느냐..

----------------------------------------------------
//JVM의 메모리 살림살이

(JVM의 메모리 구분 및 관리 기준)
-메소드 영역(method area) 
 :메소드의 바이트코드, static 변수 (특성을 기준으로 나눔)
-스택 영역(stack area)
 :지역변수, 매개변수 (특성을 기준으로 나눔)
-힙 영역(heap area)  
 :인스턴스 (특성을 기준으로 나눔)

=>메모리 공간을 용도에 따라서 별도로 나누는 이유는, 서랍장의 칸을 구분하고, 칸 별로 용도를 지정하는 이유와 차이가 없다.
  i.e 정리 잘 하기 위해서 == 메모리 엑세스가 빠름

----------------------------------------------------
//메소드 영역

(메소드 영역에 대한 설명)
-자바 바이트코드(bytecode) : 자바 가상머신에 의해서 실행되는 코드 
 (바이트코드 == 자바 가상 머신이 이해하는 코드)

-메소드의 자바 바이트코드는 JVM이 구분하는 메모리 공간 중에서 메소드 영역에 저장된다.
 
-static으로 선언된 클래스 변수도 메소드 영역에 저장된다.
 
-정리하면, 클래스의 정보가 JVM의 메모리 공간에  LOAD 될 때 할당 및 초기화되는 대상은 메소드 영역에 할당된다.

=>자바 바이트코드, 클래스 변수는 실행되면 메모리에 LOAD됨
cf)메소드의 바이트코드는 실행에 필요한 바이트코드 전부를 의미한다. 
   자바 프로그램의 실행은 메소드 내에 정의된 문장들의 실행으로 완성되기 때문이다.

----------------------------------------------------

//스택 영역
(스택 영역에 대한 설명)
-매개변수, 지역변수가 할당되는 메모리 공간
-프로그램이 실행되는 도중에 임시로 할당되었다가 바로 이어서 소멸되는 특징이 있는 변수가 할당된다.
-메소드의 실행을 위한 메모리 공간으로도 정의할 수 있다.

//스택의 흐름
;메소드를 실행하기 위한 메모리 공간

-지역변수는 스택에 할당된다.
-스택에 할당된 지역변수는 해당 메소드를 빠져 나가면 소멸된다.
-할당 및 소멸의 특성상 그 형태가 접시를 쌓는 것과 유사하다 따라서 스택이라 이름 지어 졌다.

==>할당 및 소멸의 특성상 메소드 별 스택이 구분이 된다.
----------------------------------------------------

//힙 영역

-인스턴스가 생성되는 메모리 공간

-JVM에 의한 메모리 공간의 정리(Garbage Collection)가 이뤄지는 공간
 =>정해진 알고리즘에 의해 스케쥴링 된 시간에 따라서 활동

-할당 : 프로그래머 //소멸 : JVM

-참조변수에 의한 참조가 전혀 이뤄지지 않는 인스턴스가 소멸의 대상이 된다. 
 따라서 JVM은 인스턴스의 참조관계를 확인하고 소멸할 대상을 선정한다.

=>기준:외부에서 참조하는 참조변수가 없으면 할당 해제
메소드 내에서 인스턴스를 생성한다면 위의 그림에서 설명하듯이 참조변수는 스택에 인스턴스는 힙에 저장된다.

----------------------------------------------------

//인스턴스의 소멸시기

	public static void main(String[] args){
		String str1=new String("My String");
		String str2=new String("Your String");
		...
		//(1)
		str1=null;
		str2=null;
		....

	}

=>(1)부분이 실행되고 나면, 기존 인스턴스를 참조하는 변수가 없음
=>즉, 참조되지 않는 인스턴스가 소멸의 대상 & 가비지 컬렉션(Garbage Collection)에 의해서 메모리 할당 해제

cf)가비지 컬렉션이 발생하는 정확한 시점
=>인스턴스가 가비지 컬렉션의 대상이 되었다고 해서 바로 소멸이 되는 것은 아님
=>빈번한 가비지 컬렉션의 실행은 시스템에 부담이 될 수 있기 때문에, 성능에 영향이 미치지 않도록 해야됨
=>가비지 컬렉션의 실행 타이밍은 별도의 알고리즘을 기반으로 계산 & 계산결과를 기반으로 가비지 컬렉션이 수행됨.

----------------------------------------------------

//19-2 Object 클래스
1)equals 2)clone <<알아야 할 메소드

//인스턴스 소멸 시 호출되는 finalize 메소드 (+Garbage Collection의 동작 설명위해, 실제로 잘 활용은 안됨)

protected void finalize() throws Throwable
; 인스턴스가 완전히 소멸되기 직전 호출되는 메소드, Object 클래스의 멤버이므로 모든 인스턴스에는 이 메소드가 존재한다.


class MyName
{
 String objName;
 public MyName(String name)
 {
  objName=name;
 }
 
 protected void finalize() throws Throwable
 {
  super.finalize();
  System.out.println(objName+"이 소멸되었습니다.");
 }
}


public class ObjectFinalize {
 public static void main(String[] args){
  MyName obj1=new MyName("인스턴스1");
  MyName obj2=new MyName("인스턴스2");
  obj1=null;
  obj2=null;
  
  System.out.println("프로그램을 종료합니다.");
  // System.gc();
  // System.runFinalization();  
 }
}

=>프로그램을 종료하면서 G.C이 동작안하고 통째로 지워질 수 있음. 그래서 finalize()가 실행안될 수도 있다.
=>System.gc(); //G.C가 동작한다.
(Garbage Collection이 동작하면서 소멸 할 인스턴스를 체크는 함. BUT JVM의 상황에 따라 바로 소멸되지 않을 수도 있다.
 =>finalize() 의 호출을 보장할 수 없다.)
=>System.runFinalization();

==>G.C은 일정한 알고리즘 or 여유가 있을 때 등 프로그램이 효율적으로 작동할 수 있도록 설계되어있음
==>G.C이 실행이 되면 소멸 할 인스턴스를 체크는 하지만 바로 소멸할지 안할지는 설계된 G.C에 따라
==>간혹가다가 G.C의 동작을 아는 것이 유용할 수가 있음

----------------------------------------------------

//Garbage Collection에 대한 추가 설명

-GC는 한 번도 발생하지 않을 수 있다.

-GC가 발생하면, 소멸의 대상이 되는 인스턴스는 결정되지만 이것이 실제 소멸로 바로 이어지지는 않는다.

-인스턴스의 실제 소멸로 이어지지 않은 상태에서 프로그램이 종료될 수도 있다. 종료가 되면 어차피 인스턴스(할당된 것들)는 소멸 되니까

-따라서 반드시 finalize 메소드가 반드시 호출되기 원한다면 아래에서 보이는 코드가 추가로 삽입되어야 한다.
System.gc();   		  //Garbage Collection을 명령함!
System.runFinalization(); //GC에 의해서 소멸이 결정된 인스턴스를 즉시 소멸

----------------------------------------------------

//finalize 메소드의 오버라이딩의 예

 protected void finalize() throws Throwable
 {
  super.finalize();
  System.out.println(objName+"이 소멸되었습니다.");
 }

super.finalize();
=>finalize 메소드를 오버라이딩 하면, Object클래스의 finalize 메소드는 안에 비어있든, 채워져 있든 상관없이 
  안정성을 위해서는 super키워드를 통해 호출하는게 좋음(안에 중요한 코드가 있을 수 있으니까)
=>super.finalize();를 씀으로써 기존 메소드의 기능 + 내가 원하는 추가적인 기능을 제공할 수 있다.
=>super.finalize();를 보면 1)중요한 것이 있어서 썼구나 or 2)거기에 대한 정보가 부족해도 쓸 수 있음

-Object 클래스에 정의되어 있는 finalize 메소드에 중요한 코드가 삽입되어 있는지 확인한바 없다!
 =>확인하라는게 아니라 공학적인 측면(쉽게 가져다 쓰고 쉽게 문제를 일으키지 않고 활용)에서도
   객체지향은 모든 것을 보는게 아님.내가 보기 원하는 특정 부분만 보고 확장할 수 있어야됨
 
-만약에 중요한 코드가 삽입되어 있다면? 단순한 오버라이딩으로 인해서 중요한 코드의 실행을 방해할 수 있다.

-따라서 대상 메소드에 대한 정보가 부족한 경우에는 오버라이딩 된 메소드도 호출이 되도록 오버라이딩 하자.
 이것이 오버라이딩의 기본 원칙이다.


 

 

 

 

 

 

 

















